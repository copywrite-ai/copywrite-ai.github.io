<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyNanoCloud</title>
    <style>
        body, html { margin: 0; padding: 0; background: #050505; overflow: hidden; font-family: 'Inter', sans-serif; }
        
        #viewport { width: 100vw; height: 100vh; overflow: hidden; position: relative; }
        
        /* æ‘„åƒæœºå±‚ */
        #camera-layer {
            width: 1600px;
            height: 1200px;
            background: #111;
            transform-origin: 0 0;
            will-change: transform;
            position: relative;
            /* ç½‘æ ¼èƒŒæ™¯ï¼Œæ–¹ä¾¿è§‚å¯Ÿç§»åŠ¨ */
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 40px 40px;
        }

        /* --- æ¨¡æ‹Ÿå…‰æ ‡ --- */
        #fake-cursor {
            position: absolute; width: 20px; height: 20px;
            background: red; border-radius: 50%; /* ç”¨çº¢ç‚¹ä»£è¡¨å…‰æ ‡ï¼Œæ–¹ä¾¿çœ‹æ¸…ä½ç½® */
            pointer-events: none; z-index: 9999; top: 0; left: 0;
            box-shadow: 0 0 10px rgba(255,0,0,0.8);
            transition: transform 0.1s linear;
        }
        #fake-cursor::after { content: "Cursor"; position: absolute; left: 24px; top: 0; color: red; font-size: 10px; font-weight: bold; }

        /* --- UI å…ƒç´  --- */
        .container { padding: 50px; display: flex; gap: 40px; }
        
        .sidebar { width: 250px; height: 600px; background: #1a1a1a; border-radius: 12px; border: 1px solid #333; padding: 20px; }
        .menu-item { height: 20px; background: #333; margin-bottom: 10px; border-radius: 4px; width: 60%; }

        .content { flex: 1; }
        
        h1 { color: #fff; margin-bottom: 10px; }
        p { color: #666; max-width: 500px; margin-bottom: 40px; }

        /* ğŸŒŸ æ ¸å¿ƒæµ‹è¯•å¯¹è±¡ï¼šæ™ºèƒ½æ„å›¾åŒºåŸŸ ğŸŒŸ */
        /* ç»™è¿™äº›å…ƒç´ åŠ ä¸Š .smart-frame ç±»ï¼Œæ¨¡æ‹Ÿç®—æ³•è¯†åˆ«å‡ºçš„â€œé«˜ä»·å€¼åŒºåŸŸâ€ */
        .smart-frame {
            position: relative;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        /* æ¿€æ´»çŠ¶æ€ä¸‹çš„è§†è§‰åé¦ˆ */
        .smart-frame.active-frame {
            border-color: #007acc;
            box-shadow: 0 0 0 4px rgba(0, 122, 204, 0.1);
        }

        /* åœºæ™¯ 1: å¤§æ®µæ–‡æœ¬ */
        #text-block {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 40px;
            border-radius: 12px;
            max-width: 600px;
            color: #ccc;
            line-height: 1.8;
            font-size: 16px;
        }

        /* åœºæ™¯ 2: å®½å¤§çš„ Dashboard è¡¨æ ¼ */
        #wide-table {
            margin-top: 50px;
            width: 900px; /* ç‰¹åˆ«å®½ï¼Œéœ€è¦ Zoom Out æ‰èƒ½çœ‹å®Œ */
            height: 300px;
            background: #151515;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        .cell { background: #222; border-radius: 6px; }

        /* çŠ¶æ€æŒ‡ç¤º */
        #hud {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #000; border: 1px solid #333; color: #0f0; padding: 10px 20px;
            font-family: monospace; border-radius: 8px; z-index: 10000;
        }
    </style>
</head>
<body>

<div id="hud">Mode: Free Follow (Move mouse to test)</div>

<div id="viewport">
    <div id="camera-layer">
        <div id="fake-cursor"></div>
        
        <div class="container">
            <div class="sidebar">
                <div style="color:white; margin-bottom:20px; font-weight:bold;">Menu</div>
                <div class="menu-item" style="width:80%"></div>
                <div class="menu-item"></div>
                <div class="menu-item"></div>
            </div>

            <div class="content">
                <h1>Auto-Framing Algorithm</h1>
                <p>Move the red cursor into the blocks below. Notice how the camera detaches from the cursor to show the full context.</p>

                <!-- ğŸŒŸ æµ‹è¯•å¯¹è±¡ 1ï¼šæ–‡æœ¬å— ğŸŒŸ -->
                <div id="text-block" class="smart-frame">
                    <h3 style="color:#fff; margin-top:0;">1. The "Readme" Scenario</h3>
                    <p style="color:#888;">
                        Wait here! Even if you move the cursor to the corners of this box, the camera stays centered. <br><br>
                        Screen Studio recognizes that this is a <strong>semantic unit</strong>. It calculates a bounding box and forces the camera to "fit" this element into the viewport with a comfortable padding. This prevents the "shaky cam" effect when reading long texts.
                    </p>
                    <div style="background:#222; padding:10px; border-radius:4px; font-family:monospace; color:#dcdcaa;">
                        npm install smart-camera-system
                    </div>
                </div>

                <!-- ğŸŒŸ æµ‹è¯•å¯¹è±¡ 2ï¼šè¶…å®½å…ƒç´  ğŸŒŸ -->
                <div id="wide-table" class="smart-frame">
                    <div style="grid-column: span 4; color: white; margin-bottom: 10px; font-weight: bold;">
                        2. The "Wide Dashboard" Scenario (Requires Zoom Out)
                    </div>
                    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                </div>

            </div>
        </div>
    </div>
</div>

<script>
    const CONFIG = {
        friction: 0.05,
        padding: 0.2, // 20% ç•™ç™½
        viewportW: window.innerWidth,
        viewportH: window.innerHeight,
        defaultScale: 1.2
    };

    const state = {
        cam: { x: 0, y: 0, scale: 1 },
        target: { x: 0, y: 0, scale: 1 },
        cursor: { x: 400, y: 300 }, // è™šæ‹Ÿå…‰æ ‡çš„ç»å¯¹åæ ‡
        activeElement: null // å½“å‰é”å®šçš„å…ƒç´ 
    };

    const els = {
        layer: document.getElementById('camera-layer'),
        cursor: document.getElementById('fake-cursor'),
        hud: document.getElementById('hud')
    };

    // æ¯ä¸€å¸§çš„ç‰©ç†å¾ªç¯
    function tick() {
        // --- æ ¸å¿ƒé€»è¾‘ï¼šå†³ç­–ç›®æ ‡ä½ç½® ---
        if (state.activeElement) {
            // A. é”å®šæ¨¡å¼ï¼šæ— è§†å…‰æ ‡ï¼Œç›¯ç€å…ƒç´ ä¸­å¿ƒ
            // æˆ‘ä»¬å·²ç»ç®—å¥½äº† targetï¼Œè¿™é‡Œä¸éœ€è¦æ¯å¸§é‡ç®—ï¼Œé™¤éå…ƒç´ åœ¨åŠ¨
        } else {
            // B. è‡ªç”±æ¨¡å¼ï¼šè·Ÿéšå…‰æ ‡
            state.target.x = state.cursor.x;
            state.target.y = state.cursor.y;
            state.target.scale = CONFIG.defaultScale;
        }

        // --- ç‰©ç†å¹³æ»‘ (Lerp) ---
        state.cam.x += (state.target.x - state.cam.x) * CONFIG.friction;
        state.cam.y += (state.target.y - state.cam.y) * CONFIG.friction;
        state.cam.scale += (state.target.scale - state.cam.scale) * (CONFIG.friction * 0.8);

        // --- æ¸²æŸ“ ---
        // æ³¨æ„ï¼šTranslate éœ€è¦åŸºäº Scale åå‘è¡¥å¿ï¼Œä¿æŒæ‘„åƒæœºä¸­å¿ƒå¯¹å‡†ç›®æ ‡
        const tx = (CONFIG.viewportW / 2) - (state.cam.x * state.cam.scale);
        const ty = (CONFIG.viewportH / 2) - (state.cam.y * state.cam.scale);

        els.layer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${state.cam.scale})`;
        
        requestAnimationFrame(tick);
    }
    tick();

    // --- ç®—æ³•æ ¸å¿ƒï¼šæ™ºèƒ½æ„å›¾è®¡ç®— ---
    function checkSmartFraming(x, y) {
        // 1. ç¢°æ’æ£€æµ‹ï¼šå…‰æ ‡ä¸‹é¢æœ‰ä¸œè¥¿å—ï¼Ÿ
        // æ³¨æ„ï¼šå› ä¸ºæˆ‘ä»¬æ˜¯æ¨¡æ‹Ÿå…‰æ ‡ï¼Œè¿™é‡Œç”¨ document.elementFromPoint æ¨¡æ‹Ÿ
        // åœ¨å®é™…å½•å±è½¯ä»¶ä¸­ï¼Œè¿™æ˜¯é€šè¿‡æ“ä½œç³»ç»Ÿ Accessibility API è·å–çš„
        
        // ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬æ‰‹åŠ¨åˆ¤æ–­å…‰æ ‡æ˜¯å¦åœ¨æŸä¸ª .smart-frame çš„ rect å†…
        const frames = document.querySelectorAll('.smart-frame');
        let found = null;

        // å¿…é¡»æŠŠå…‰æ ‡åæ ‡è½¬æ¢æˆ DOM åæ ‡ (è¿™é‡Œå› ä¸ºå…‰æ ‡å°±åœ¨ layer é‡Œï¼Œç›´æ¥ç”¨)
        frames.forEach(el => {
            // è®¡ç®—å…ƒç´ ç›¸å¯¹äº layer çš„ç»å¯¹ä½ç½® (ç®€æ˜“ç‰ˆï¼Œä¸è€ƒè™‘æ—‹è½¬)
            const rect = {
                left: el.offsetLeft,
                top: el.offsetTop,
                width: el.offsetWidth,
                height: el.offsetHeight
            };
            // é€’å½’çˆ¶çº§ offset
            let p = el.offsetParent;
            while(p && p.id !== 'camera-layer') {
                rect.left += p.offsetLeft;
                rect.top += p.offsetTop;
                p = p.offsetParent;
            }

            // AABB ç¢°æ’æ£€æµ‹
            if (x >= rect.left && x <= rect.left + rect.width &&
                y >= rect.top && y <= rect.top + rect.height) {
                found = { el, rect };
            }
        });

        // 2. çŠ¶æ€åˆ‡æ¢é€»è¾‘
        if (found) {
            if (state.activeElement !== found.el) {
                // --> è¿›å…¥æ–°å…ƒç´ 
                state.activeElement = found.el;
                found.el.classList.add('active-frame');
                els.hud.innerText = "Mode: LOCKED on Block (Auto-Fit)";
                els.hud.style.color = "#007acc";
                els.hud.style.borderColor = "#007acc";

                // 3. è®¡ç®—æœ€ä½³æ„å›¾ (Fit-to-Screen)
                const center = {
                    x: found.rect.left + found.rect.width / 2,
                    y: found.rect.top + found.rect.height / 2
                };

                // è®¡ç®—ç¼©æ”¾ï¼šæˆ‘ä»¬è¦è®©å…ƒç´ å å±å¹•å®½åº¦çš„ (1 - padding)
                // æ¯”å¦‚å±å¹•å®½ 1920ï¼Œå…ƒç´ å®½ 600ï¼Œç•™ç™½ 20% -> ç›®æ ‡å®½ 1920 / 1.2 = 1600
                // æ”¾å¤§å€æ•° = 1600 / 600
                
                // å®½é€‚é…
                const scaleX = CONFIG.viewportW / (found.rect.width * (1 + CONFIG.padding));
                // é«˜é€‚é… (é˜²æ­¢é•¿æ–‡ä¸‹é¢è¢«åˆ‡æ‰)
                const scaleY = CONFIG.viewportH / (found.rect.height * (1 + CONFIG.padding));

                // å–è¾ƒå°å€¼ï¼Œä¿è¯å®Œå…¨æ”¾å…¥å±å¹•
                let fitScale = Math.min(scaleX, scaleY);
                
                // é™åˆ¶ä¸€ä¸‹ï¼Œåˆ«æ”¾å¤ªå°ï¼Œä¹Ÿåˆ«æ”¾å¤ªå¤§
                fitScale = Math.min(Math.max(fitScale, 0.6), 2.0);

                state.target.x = center.x;
                state.target.y = center.y;
                state.target.scale = fitScale;
            }
        } else {
            if (state.activeElement) {
                // --> ç¦»å¼€å…ƒç´ 
                state.activeElement.classList.remove('active-frame');
                state.activeElement = null;
                els.hud.innerText = "Mode: Free Follow";
                els.hud.style.color = "#0f0";
                els.hud.style.borderColor = "#333";
            }
        }
    }

    // --- è‡ªåŠ¨åŒ–è„šæœ¬ ---
    const wait = ms => new Promise(r => setTimeout(r, ms));

    async function runDemo() {
        // åˆå§‹ä½ç½®
        state.cursor = { x: 200, y: 300 };
        updateCursorVisual();

        await wait(1000);

        // 1. ç§»åŠ¨åˆ°æ–‡æœ¬å— (è§¦å‘ Auto-Framing)
        await glideTo(600, 400); // ç§»åŠ¨åˆ° #text-block ä¸­å¿ƒé™„è¿‘
        
        // 2. åœ¨æ–‡æœ¬å—å†…éƒ¨ä¹±æ™ƒ (æ¼”ç¤º Camera Lock)
        // å“ªæ€•é¼ æ ‡åœ¨åŠ¨ï¼Œæ‘„åƒæœºåº”è¯¥çº¹ä¸ä¸åŠ¨
        await wait(500);
        await glideTo(550, 380, 400);
        await glideTo(650, 420, 400);
        await glideTo(580, 450, 400);
        
        await wait(1000);

        // 3. ç¦»å¼€æ–‡æœ¬å— (æ¢å¤ Free Follow)
        await glideTo(900, 200); // ç§»åˆ°ä¸­é—´ç©ºç™½å¤„
        
        await wait(1000);

        // 4. ç§»åŠ¨åˆ°å®½è¡¨æ ¼ (è§¦å‘ Zoom Out)
        await glideTo(1100, 800); // ç§»åˆ° #wide-table
        
        await wait(2000);

        // 5. ç»“æŸå¾ªç¯
        await glideTo(200, 300);
        runDemo();
    }

    // ç®€å•çš„å¹³æ»‘å…‰æ ‡ç§»åŠ¨å‡½æ•°
    async function glideTo(x, y, duration = 1000) {
        const startX = state.cursor.x;
        const startY = state.cursor.y;
        const startTime = performance.now();

        return new Promise(resolve => {
            function step(now) {
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                // Ease In Out
                const ease = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                state.cursor.x = startX + (x - startX) * ease;
                state.cursor.y = startY + (y - startY) * ease;
                
                updateCursorVisual();
                
                // å…³é”®ï¼šæ¯å¸§æ£€æµ‹æ™ºèƒ½æ„å›¾
                checkSmartFraming(state.cursor.x, state.cursor.y);

                if (progress < 1) requestAnimationFrame(step);
                else resolve();
            }
            requestAnimationFrame(step);
        });
    }

    function updateCursorVisual() {
        els.cursor.style.transform = `translate(${state.cursor.x}px, ${state.cursor.y}px)`;
    }

    // å¯åŠ¨
    runDemo();

</script>
<script
    src="https://analytics.crawlconsole.com/tracker.js"
    data-project-key="804424a5-1041-4dee-8a62-a4d1269016c8"
    defer
></script>
</body>
</html>
